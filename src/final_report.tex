\documentclass[10pt]{article}
\usepackage[margin=1.5in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{authblk}
\usepackage{titlesec}
\usepackage{svg}
\begin{document}

\title{ARM11 Project Final Report}
\author{C Group 03}
\affil{Andy Chen, HouWang Wong, Jeshuran Jebanesan, Jiaju Yang}

\maketitle

\section{Abstract}
The aim of this project is to develop an ARM11 assembler that can decode basic ARM11 assembly language and translates into binary machine code. The task is done in a two-pass algorithm: recording any symbol for branch instructions and store them into a table in the first pass, and replacing these symbols with their corresponding value during the translation process in the second pass. In addition, a three-player chess game for a hexagonal 96-tile board is implemented as a C program extension, which includes the board logic code, a chessboard GUI and socket programming.
\section{Assembler}
\subsection{General structure}
For the assembler, a test-driven approach was taken, where the testing framework for the functions were designed first, then the functions themselves were defined. From the development experience in the first half of the project, the fact that only a few function tests were performed before debugging stage would result in a long debugging time due to the difficulty of pinning down the problematic parts of the code.
As shown in Figure 1, the structure was divided into 4 main parts.
\begin{figure}
\centering
\begin{minipage}{.5\textwidth}
\centering
\includegraphics[width = \linewidth]{ flow }
\caption{Assembler workflow chart}
\label{fig:assembler}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
\centering
\includegraphics[width = \linewidth]{ mem_array }
\caption{Encapsulated structure of the polymorphic memory array}
\label{fig:mem_array}
\end{minipage}
\end{figure}

\subsubsection{First pass: Parser and Tokenizer}
In the first pass, the assembly file was read line by line until the end of the file. The number of words in each line was kept track of. If there was only one word in a line, that line would be a label. If so, the label would be added to the symbol table. If the line was a normal instruction instead, then the opcode and operands would be stored inside a singly linked list representing the disassembled lines.
\subsubsection{Second pass}
In the second pass, the linked list of disassembled lines were processed in a recursive manner. Each line was mapped to the corresponding translate function pointer and a default condition binary code. The function is then executed to produce the required binary. This made the functions more independent and making it easier to carry out function testings.
    
\subsubsection{Translate functions}
Similar to the emulator, the assembly lines and the respective functions are categorized into 4 main types: data process, data transfer, multiply and branch, and function pointers were applied as well.  There were several similarities in how different categories of lines are decoded so helper functions were created to reduce code duplication.

\subsubsection{Output}
The binary lines would then be converted to little-endian format and printed out into the output file.

\subsection{Challenges}
A problem was to choose the appropriate form of data representation for assembly lines. The original method was to use a dynamic array like the memory array that was implemented early on. This required the assemble lines to be looped through twice which reduced efficiency. We got around this by using the linked list. Even though a linked list complexity is higher than static array, the assemble lines are read sequentially, which makes the execution time similar to a static array.\newline
For the symbol table, we used the memory array data structure from the emulator because:
    
1. The size of array is unknown, which could be solved with memory array's internal reallocation function.
    
2. Memory array can be used to store any type of element. The type conversion would be defined at the interface shown in Figure 2.

\section{Extension: Three-player Chess}
The theme chosen for the extension part of the project is a three-player chess game played on a hexagonal, 96-tile chessboard featuring online multiplayer. Although there are many variants involving different shapes of boards and rules, the most straight-forward and regular-chess-like rules are selected.
\subsection{Game Design}
\subsubsection{Board layout}
As shown in Figure 3, the board can be divided into 3 sections with size of 8 rows * 4 columns, which is assigned to the three players of colour black, white and red. The tiles can be labelled into a combination of 12 numbers and 8 letters, just like regular chess. The initial state for one side of the board is exactly the same as regular chess.
\subsubsection{Rules}
The rules generally follows from regular chess; In fact, whenever a piece is considering moves within the three 8*4 areas mentioned in 3.1.1, the possible moves are the same as in regular chess. Therefore, castling and promotions are also possible. The difference is when the piece attempts to cross the "rosette tiles" located at the centre of the board (d4, e4, d5, i5, i9, e9) and the "side" tiles (on rows 4, 5, 9, including the rosette tiles). There are two additional rules accounting for these kinds of movements:

1. When a piece on the rosette tiles is considering moves on the diagonal line towards the board center, the diagonal path would divert into two, or more specifically, continues on the two tiles with the same color;

2. When a piece on the side tiles is considering moves on the vertical line or diagonal line towards the distorted edge, the direction diverts to the nearest side tile (with the same color if diagonal) and continues from there on.

Hence, as shown in Figure 4, the left king's diagonal movement towards the board center will be diverted into two direction, and the vertical movement and diagonal movement towards the left 8*4 area will land on the nearest tile with a different colour and an identical colour respectively. These two rules applies to all pieces.

\begin{figure}
\centering
\begin{minipage}{.5\textwidth}
\centering
\includesvg[width = \linewidth]{ board }
\caption{Hexagonal chessboard}
\label{fig:board}
\end{minipage}\hfill
\begin{minipage}{.5\textwidth}
\centering
\includegraphics[width = \linewidth]{ king_moves }
\caption{Possible moves for King}
\label{fig:moves}
\end{minipage}
\end{figure}

\subsubsection{Legal Moves}
Following from the rules, the moves generated are in a stage called pseudo-legal move. What differs them from actual legal moves is that legal moves would never put their king in check after the move has commenced.
\subsubsection{Objective for the Game}
The main objective for the three players will still be the first to checkmate another player, that is, to pin down the opponent's king in a situation that no legal move is available to the opponent. Once the game is in a state of checkmate (as well as draw, which can be voted as an end-game option mid-game, or stalemate, meaning that a player has no legal move without being checked) it will then conclude, and 1 point will be added to the winning player.
\subsection{Code structure}
The general code structure could be split into three parts: Board Logic, GUI Design and Rendering and socket programming for multiplayer. They were generally written in C, with the usage of socket communication libraries and Unity Engine for GUI Design.
\subsubsection{Board Logic}
The Board Logic code manages the board state, checks and processes legal piece moves, generate available moves during the process and maintains the game state. After initialising the memory and board state, the game starts with the white player and loops through the order of red, black and white. It will first check for game state and decide if the game proceeds or concludes. Then, for every click on an ally piece, the available moves are produced and sent to the GUI for rendering and checks for another click on the available tiles. If the second click is on the available tiles, it will then process the move and check for castling and promotion.\newline
The algorithm for generating available moves generally follows from 3.1.2, with the usage of vectors to generate all moves in a loop. Using this algorithm, the program can check for king checks simply by generating all enemy pieces' moves and matching them with the ally king's coordinates. In a similar manner, legal moves are checked by plugging the modified board with the pseudo-legal move commenced.
\subsubsection{GUI Design}
The second part is the GUI design which is done in Unity Engine. It includes the rendering of the chessboard model mentioned before, as well as the chess pieces in three colors and the tile color change when showing available moves, whenever a player clicks on any piece.
\subsubsection{Socket Programming}
The third part is a communication program that builds a LAN connection between the three players and passes through information such as click coordinates, board states etc.
\section{Reflections}
\section{Group Reflection}
The team collaboration was smooth and efficient throughout the process. From splitting our work evenly and divide the independent works into different files, to communicating through Discord, tracking progress on Trello, organising offline meetings and coding sessions, every member are always on the same page and working on different things. Although there are hiccups in between the planning stage and coding stage for the extension concerning the use and learning progress of the GTK+ library, in general every member contributed in many parts of the project, and the progress made are all crucial to the final product.
\subsection{Individual Reflections}
\subsubsection{Andy Chen}
\subsubsection{HouWang Wong}
During the first stage, as I have had quite a bit experience with the C language before, I could quickly complete my parts and started debugging and implementing additional features. However for the second part, I have to admit that I misjudged the time necessary for me to learn the GTK+ library, let alone the limits of the library when compared to the Unity Engine and other game design engines. Despite that, I completed the refinement of both reports, presentation slides and scripts, which I am experienced with. This experience will definitely remind me in further projects to carefully assess my capabilities and the time limit before planning.
\subsubsection{Jeshuran Jebanesan}
\subsubsection{Jiaju Yang}
\end{document}